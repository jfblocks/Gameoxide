<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç«‹ä½“å››å­æ£‹ (Connect Four 3D)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --p1-color: #ef4444; /* red-500 */
            --p2-color: #facc15; /* yellow-400 */
            --bg-color: #1f2937; /* gray-800 */
            --cell-bg: #4b5563; /* gray-600 */
            --board-bg: #374151; /* gray-700 */
        }
        .cell.player1 { background-color: var(--p1-color); }
        .cell.player2 { background-color: var(--p2-color); }

        .cell-container {
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        .cell-container:hover {
            background-color: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        .shaft-full .cell-container:hover {
            background-color: transparent;
            cursor: not-allowed;
        }

        .cell {
            width: 100%;
            padding-bottom: 100%; /* Aspect ratio 1:1 */
            background-color: var(--cell-bg);
            border-radius: 50%;
            transition: transform 0.2s ease-in-out, background-color 0.3s;
        }
        
        /* 3D Cube Preview Styles */
        .scene {
            perspective: 1200px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .cube {
            width: 200px;
            height: 200px;
            position: relative;
            transform-style: preserve-3d;
            animation: spin 25s infinite linear;
        }
        .preview-cell {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            transition: background-color 0.5s, transform 0.5s;
        }
        .preview-cell.empty {
            background-color: rgba(75, 85, 99, 0.2);
        }
        .preview-cell.player1 {
            background-color: var(--p1-color);
            box-shadow: 0 0 8px var(--p1-color);
        }
        .preview-cell.player2 {
            background-color: var(--p2-color);
            box-shadow: 0 0 8px var(--p2-color);
        }

        @keyframes spin {
            from { transform: rotateX(-25deg) rotateY(0deg); }
            to { transform: rotateX(-25deg) rotateY(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen font-sans p-4">

    <header class="text-center mb-6">
        <h1 class="text-4xl md:text-5xl font-bold tracking-tight">ç«‹ä½“å››å­æ£‹</h1>
        <p class="text-gray-400 mt-2">åœ¨ 4x4x4 çš„ç©ºé—´ä¸­è¿æˆå››å­ï¼</p>
    </header>

    <div class="w-full max-w-7xl grid grid-cols-1 lg:grid-cols-3 gap-8">
        <!-- Game Board Section -->
        <main id="game-container" class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-2xl w-full lg:col-span-2">
            <!-- Controls -->
            <div class="flex flex-col sm:flex-row justify-between items-center mb-4 gap-4">
                <div id="status-display" class="text-xl font-semibold h-8 flex items-center"></div>
                <div class="flex gap-2 sm:gap-4">
                    <select id="game-mode" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <option value="pvp">åŒäººå¯¹æˆ˜ (PvP)</option>
                        <option value="pve">äººæœºå¯¹æˆ˜ (PvE)</option>
                    </select>
                    <button id="restart-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors">
                        é‡æ–°å¼€å§‹
                    </button>
                </div>
            </div>

            <!-- Game Board -->
            <div id="game-board" class="flex flex-row gap-4 md:gap-6 overflow-x-auto pb-4">
                <!-- Boards will be generated by JS -->
            </div>
        </main>

        <!-- Sidebar Section -->
        <aside class="flex flex-col gap-8">
            <div class="bg-gray-800 p-6 rounded-xl shadow-2xl">
                <h2 class="text-2xl font-bold mb-4 text-center">æ¸¸æˆä¿¡æ¯</h2>
                <button id="rules-btn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-md transition-colors">
                    ç©æ³•è¯´æ˜
                </button>
            </div>
            <div class="bg-gray-800 p-6 rounded-xl shadow-2xl flex-grow flex flex-col">
                <h2 class="text-2xl font-bold mb-4 text-center">ç«‹æ–¹ä½“é¢„è§ˆ</h2>
                <div id="cube-preview-container" class="scene flex-grow min-h-[250px]"></div>
            </div>
        </aside>
    </div>

    <!-- Rules Modal -->
    <div id="rules-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full p-8 relative">
            <button id="close-modal-btn" class="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">&times;</button>
            <h2 class="text-3xl font-bold mb-4 text-center">ç©æ³•è¯´æ˜</h2>
            <div class="text-gray-300 space-y-3">
                <p><strong>ç›®æ ‡ï¼š</strong>æˆä¸ºç¬¬ä¸€ä¸ªå°†è‡ªå·±çš„å››ä¸ªæ£‹å­è¿æˆä¸€æ¡ç›´çº¿çš„ç©å®¶ã€‚</p>
                <p><strong>æ£‹ç›˜ï¼š</strong>æ¸¸æˆåœ¨ä¸€ä¸ª 4x4x4 çš„ç«‹ä½“ç©ºé—´ä¸­è¿›è¡Œã€‚ç•Œé¢ä¸Šä»å·¦åˆ°å³çš„å››ä¸ªç½‘æ ¼åˆ†åˆ«ä»£è¡¨ç«‹æ–¹ä½“ä»**åº•éƒ¨åˆ°é¡¶éƒ¨**çš„å››ä¸ªå±‚é¢ã€‚</p>
                <p><strong>ä¸‹æ£‹ (æ–°è§„åˆ™)ï¼š</strong>è½®åˆ°ä½ æ—¶ï¼Œåœ¨**ä»»æ„å±‚é¢**ä¸Šç‚¹å‡»ä¸€ä¸ª**æ ¼å­**ã€‚è¿™ä»£è¡¨ä½ é€‰æ‹©äº†ä¸€ä¸ªå‚ç›´çš„â€œäº•é“â€ã€‚ä½ çš„æ£‹å­ä¼šè‡ªåŠ¨è½åˆ°è¯¥â€œäº•é“â€ä¸­æœ€ä½çš„å¯ç”¨ä½ç½®ã€‚</p>
                <p><strong>èƒœåˆ©æ¡ä»¶ï¼š</strong>å››å­ç›¸è¿å³å¯è·èƒœã€‚è¿çº¿å¯ä»¥æ˜¯ï¼š</p>
                <ul class="list-disc list-inside pl-4 space-y-1">
                    <li><strong>æ°´å¹³çº¿ï¼š</strong>åœ¨åŒä¸€å±‚å†…çš„è¡Œã€åˆ—æˆ–å¯¹è§’çº¿ã€‚</li>
                    <li><strong>å‚ç›´çº¿ï¼š</strong>è´¯ç©¿å››ä¸ªä¸åŒå±‚é¢çš„ç›´çº¿ï¼ˆåœ¨åŒä¸€ä¸ªâ€œäº•é“â€ä¸­ï¼‰ã€‚</li>
                    <li><strong>ç©ºé—´å¯¹è§’çº¿ï¼š</strong>è´¯ç©¿æ•´ä¸ªç«‹æ–¹ä½“çš„å¯¹è§’çº¿ã€‚</li>
                </ul>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const BOARD_SIZE = 4;
            const gameBoardElement = document.getElementById('game-board');
            const statusDisplay = document.getElementById('status-display');
            const restartBtn = document.getElementById('restart-btn');
            const gameModeSelect = document.getElementById('game-mode');
            const cubePreviewContainer = document.getElementById('cube-preview-container');
            const rulesBtn = document.getElementById('rules-btn');
            const rulesModal = document.getElementById('rules-modal');
            const closeModalBtn = document.getElementById('close-modal-btn');

            let board = [];
            let currentPlayer = 1;
            let gameOver = false;
            let gameMode = 'pvp';

            const initGame = () => {
                board = Array(BOARD_SIZE).fill(0).map(() =>
                    Array(BOARD_SIZE).fill(0).map(() =>
                        Array(BOARD_SIZE).fill(0)
                    )
                );
                currentPlayer = 1;
                gameOver = false;
                gameMode = gameModeSelect.value;
                renderBoard();
                updateStatus();
            };

            const renderBoard = () => {
                gameBoardElement.innerHTML = '';
                for (let level = 0; level < BOARD_SIZE; level++) {
                    const levelElement = document.createElement('div');
                    levelElement.className = 'board-level bg-gray-700 p-2 rounded-lg shadow-lg w-48 sm:w-56 flex-shrink-0';
                    
                    let levelLabel = `ç¬¬ ${level + 1} å±‚`;
                    if (level === 0) levelLabel += ' (åº•éƒ¨)';
                    if (level === BOARD_SIZE - 1) levelLabel += ' (é¡¶éƒ¨)';
                    
                    levelElement.innerHTML = `<h3 class="text-center font-bold mb-2 text-gray-300">${levelLabel}</h3>`;
                    
                    const gridElement = document.createElement('div');
                    gridElement.className = 'board-grid grid grid-cols-4 gap-2';
                    gridElement.dataset.level = level;
                    
                    for (let row = 0; row < BOARD_SIZE; row++) {
                        for (let col = 0; col < BOARD_SIZE; col++) {
                            const cellContainer = document.createElement('div');
                            cellContainer.className = 'cell-container';
                            cellContainer.dataset.row = row;
                            cellContainer.dataset.col = col;

                            // NEW: Check if the entire shaft is full
                            if (board[BOARD_SIZE - 1][row][col] !== 0) {
                                cellContainer.classList.add('shaft-full');
                            }

                            const cellElement = document.createElement('div');
                            cellElement.className = 'cell';
                            const player = board[level][row][col];
                            if (player === 1) cellElement.classList.add('player1');
                            if (player === 2) cellElement.classList.add('player2');
                            
                            cellContainer.appendChild(cellElement);
                            gridElement.appendChild(cellContainer);
                        }
                    }
                    levelElement.appendChild(gridElement);
                    gameBoardElement.appendChild(levelElement);
                }
                addEventListenersToBoards();
                renderCubePreview();
            };

            const renderCubePreview = () => {
                cubePreviewContainer.innerHTML = '';
                const cube = document.createElement('div');
                cube.className = 'cube';

                const CELL_SIZE = 30;
                const GAP = 15;
                const TOTAL_SIZE = CELL_SIZE + GAP;
                const offset = - (BOARD_SIZE - 1) * TOTAL_SIZE / 2;

                for (let l = 0; l < BOARD_SIZE; l++) {
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            const cell = document.createElement('div');
                            cell.className = 'preview-cell';
                            const player = board[l][r][c];
                            
                            if (player === 1) cell.classList.add('player1');
                            else if (player === 2) cell.classList.add('player2');
                            else cell.classList.add('empty');

                            // MODIFIED: Re-oriented coordinates for preview
                            // x = column, y = level (height), z = row (depth)
                            const x = offset + c * TOTAL_SIZE;
                            const y = offset + (BOARD_SIZE - 1 - l) * TOTAL_SIZE; // Y is now level, inverted so 0 is at the bottom
                            const z = offset + r * TOTAL_SIZE;

                            cell.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
                            cube.appendChild(cell);
                        }
                    }
                }
                cubePreviewContainer.appendChild(cube);
            };

            const updateStatus = () => {
                if (gameOver) return;
                const playerColor = currentPlayer === 1 ? 'text-red-500' : 'text-yellow-400';
                const playerName = currentPlayer === 1 ? 'çº¢æ–¹' : 'é»„æ–¹';
                statusDisplay.innerHTML = `è½®åˆ° <span class="${playerColor} font-bold">${playerName}</span>`;
            };

            // NEW: Handles clicks based on vertical shafts
            const handleShaftClick = (e) => {
                if (gameOver || (gameMode === 'pve' && currentPlayer === 2)) return;

                const cellContainer = e.target.closest('.cell-container');
                if (!cellContainer || cellContainer.classList.contains('shaft-full')) return;

                const row = parseInt(cellContainer.dataset.row);
                const col = parseInt(cellContainer.dataset.col);

                // Find the lowest empty level in this shaft
                let landingLevel = -1;
                for (let l = 0; l < BOARD_SIZE; l++) {
                    if (board[l][row][col] === 0) {
                        landingLevel = l;
                        break;
                    }
                }

                if (landingLevel !== -1) {
                    makeMove(landingLevel, row, col);
                }
            };
            
            const makeMove = (level, row, col) => {
                if (gameOver || board[level][row][col] !== 0) return;

                board[level][row][col] = currentPlayer;
                renderBoard();

                if (checkWin(currentPlayer)) {
                    gameOver = true;
                    const playerColor = currentPlayer === 1 ? 'text-red-500' : 'text-yellow-400';
                    const playerName = currentPlayer === 1 ? 'çº¢æ–¹' : 'é»„æ–¹';
                    statusDisplay.innerHTML = `<span class="${playerColor} font-bold">${playerName}</span> è·èƒœ! ğŸ‰`;
                    return;
                }

                if (checkDraw()) {
                    gameOver = true;
                    statusDisplay.textContent = 'å¹³å±€!';
                    return;
                }

                switchPlayer();

                if (gameMode === 'pve' && currentPlayer === 2 && !gameOver) {
                    setTimeout(aiMove, 500);
                }
            };

            const switchPlayer = () => {
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                updateStatus();
            };

            // MODIFIED: Event listeners are now on the grids for delegation
            const addEventListenersToBoards = () => {
                document.querySelectorAll('.board-grid').forEach(grid => {
                    grid.addEventListener('click', handleShaftClick);
                });
            };

            const checkWin = (player) => {
                // The win checking logic itself doesn't need to change, as it correctly
                // checks all 3D dimensions of the data array.
                // 1. Horizontal (within each level: row, col, and diagonal)
                for (let l = 0; l < BOARD_SIZE; l++) {
                    for (let r = 0; r < BOARD_SIZE; r++) { // Check rows
                        if (board[l][r][0] === player && board[l][r][1] === player && board[l][r][2] === player && board[l][r][3] === player) return true;
                    }
                    for (let c = 0; c < BOARD_SIZE; c++) { // Check columns
                        if (board[l][0][c] === player && board[l][1][c] === player && board[l][2][c] === player && board[l][3][c] === player) return true;
                    }
                    // Check diagonals
                    if (board[l][0][0] === player && board[l][1][1] === player && board[l][2][2] === player && board[l][3][3] === player) return true;
                    if (board[l][0][3] === player && board[l][1][2] === player && board[l][2][1] === player && board[l][3][0] === player) return true;
                }

                // 2. Vertical (through levels)
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[0][r][c] === player && board[1][r][c] === player && board[2][r][c] === player && board[3][r][c] === player) return true;
                    }
                }

                // 3. Diagonal (through levels)
                for (let i = 0; i < BOARD_SIZE; i++) {
                    // Diagonal in row-level plane
                    if (board[0][0][i] === player && board[1][1][i] === player && board[2][2][i] === player && board[3][3][i] === player) return true;
                    if (board[0][3][i] === player && board[1][2][i] === player && board[2][1][i] === player && board[3][0][i] === player) return true;
                    // Diagonal in col-level plane
                    if (board[0][i][0] === player && board[1][i][1] === player && board[2][i][2] === player && board[3][i][3] === player) return true;
                    if (board[0][i][3] === player && board[1][i][2] === player && board[2][i][1] === player && board[3][i][0] === player) return true;
                }

                // 4. Main 3D space diagonals
                if (board[0][0][0] === player && board[1][1][1] === player && board[2][2][2] === player && board[3][3][3] === player) return true;
                if (board[0][0][3] === player && board[1][1][2] === player && board[2][2][1] === player && board[3][3][0] === player) return true;
                if (board[0][3][0] === player && board[1][2][1] === player && board[2][1][2] === player && board[3][0][3] === player) return true;
                if (board[3][0][0] === player && board[2][1][1] === player && board[1][2][2] === player && board[0][3][3] === player) return true;

                return false;
            };

            const checkDraw = () => {
                // A draw occurs if all shafts are full (i.e., the top layer is full)
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[BOARD_SIZE - 1][r][c] === 0) return false;
                    }
                }
                return true;
            };
            
            // REWRITTEN: AI logic to work with new gravity
            const aiMove = () => {
                if (gameOver) return;
                let bestMove = null; // {row, col}

                // 1. Check if AI can win by dropping in any shaft
                bestMove = findWinningShaft(2);

                // 2. Check if player can win and block
                if (!bestMove) {
                    bestMove = findWinningShaft(1);
                }

                // 3. If no winning/blocking move, choose a random valid shaft
                if (!bestMove) {
                    const validShafts = [];
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            if (board[BOARD_SIZE - 1][r][c] === 0) { // Shaft is not full
                                validShafts.push({ r, c });
                            }
                        }
                    }
                    if (validShafts.length > 0) {
                        const randomChoice = validShafts[Math.floor(Math.random() * validShafts.length)];
                        bestMove = { row: randomChoice.r, col: randomChoice.c };
                    }
                }
                
                if (bestMove) {
                    const landingLevel = getLandingLevel(bestMove.row, bestMove.col);
                    if (landingLevel !== -1) {
                        makeMove(landingLevel, bestMove.row, bestMove.col);
                    }
                }
            };

            // NEW AI HELPER: Finds the landing level for a given shaft
            const getLandingLevel = (row, col) => {
                for (let l = 0; l < BOARD_SIZE; l++) {
                    if (board[l][row][col] === 0) return l;
                }
                return -1; // Shaft is full
            };

            // NEW AI HELPER: Finds a shaft where a player can win
            const findWinningShaft = (player) => {
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const l = getLandingLevel(r, c);
                        if (l !== -1) { // If shaft is not full
                            board[l][r][c] = player; // Try move
                            if (checkWin(player)) {
                                board[l][r][c] = 0; // Revert
                                return { row: r, col: c };
                            }
                            board[l][r][c] = 0; // Revert
                        }
                    }
                }
                return null;
            };

            // Event Listeners
            restartBtn.addEventListener('click', initGame);
            gameModeSelect.addEventListener('change', initGame);
            rulesBtn.addEventListener('click', () => rulesModal.classList.remove('hidden'));
            closeModalBtn.addEventListener('click', () => rulesModal.classList.add('hidden'));
            rulesModal.addEventListener('click', (e) => {
                if (e.target === rulesModal) rulesModal.classList.add('hidden');
            });

            // Initial game start
            initGame();
        });
    </script>

</body>
</html>
