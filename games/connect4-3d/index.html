<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç«‹ä½“å››å­æ£‹ (Connect Four 3D)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --p1-color: #ef4444; /* red-500 */
            --p2-color: #facc15; /* yellow-400 */
            --bg-color: #1f2937; /* gray-800 */
            --cell-bg: #4b5563; /* gray-600 */
            --board-bg: #374151; /* gray-700 */
        }
        .cell.player1 { background-color: var(--p1-color); }
        .cell.player2 { background-color: var(--p2-color); }

        .cell-container {
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        .cell-container:hover {
            background-color: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        .shaft-full .cell-container:hover {
            background-color: transparent;
            cursor: not-allowed;
        }

        .cell {
            width: 100%;
            padding-bottom: 100%; /* Aspect ratio 1:1 */
            background-color: var(--cell-bg);
            border-radius: 50%;
            transition: transform 0.2s ease-in-out, background-color 0.3s;
        }
        
        /* 3D Cube Preview Styles */
        .scene {
            perspective: 1500px;
            perspective-origin: center center;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(ellipse at center, rgba(59, 130, 246, 0.1) 0%, rgba(0, 0, 0, 0.3) 70%);
            border-radius: 1rem;
            overflow: hidden;
            position: relative;
        }
        
        .scene::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.05) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
        }
        
        .cube {
            width: 240px;
            height: 240px;
            position: relative;
            transform-style: preserve-3d;
            animation: spin 30s infinite linear;
            filter: drop-shadow(0 20px 40px rgba(0, 0, 0, 0.4));
            z-index: 1;
        }
        
        .cube:hover {
            animation-play-state: paused;
            transform: rotateX(-25deg) rotateY(45deg) scale(1.05);
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .preview-cell {
            position: absolute;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(4px);
        }
        
        .preview-cell.empty {
            background: linear-gradient(135deg, 
                rgba(75, 85, 99, 0.15) 0%, 
                rgba(55, 65, 81, 0.3) 50%, 
                rgba(31, 41, 55, 0.2) 100%);
            border-color: rgba(156, 163, 175, 0.2);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 2px rgba(255, 255, 255, 0.1);
        }
        
        .preview-cell.empty:hover {
            background: linear-gradient(135deg, 
                rgba(75, 85, 99, 0.25) 0%, 
                rgba(55, 65, 81, 0.4) 50%, 
                rgba(31, 41, 55, 0.3) 100%);
            transform: scale(1.1);
        }
        
        .preview-cell.player1 {
            background: linear-gradient(135deg, 
                var(--p1-color) 0%, 
                #dc2626 50%, 
                #b91c1c 100%);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 
                0 0 20px rgba(239, 68, 68, 0.6),
                0 0 40px rgba(239, 68, 68, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.2),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .preview-cell.player2 {
            background: linear-gradient(135deg, 
                var(--p2-color) 0%, 
                #eab308 50%, 
                #ca8a04 100%);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 
                0 0 20px rgba(250, 204, 21, 0.6),
                0 0 40px rgba(250, 204, 21, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.2),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .preview-cell.player1:hover,
        .preview-cell.player2:hover {
            transform: scale(1.15);
            filter: brightness(1.2);
        }

        @keyframes spin {
            from { transform: rotateX(-20deg) rotateY(0deg) rotateZ(-5deg); }
            to { transform: rotateX(-20deg) rotateY(360deg) rotateZ(-5deg); }
        }
        
        @keyframes pulse-glow {
            0%, 100% { 
                box-shadow: 
                    0 0 20px currentColor,
                    0 0 40px currentColor,
                    0 4px 12px rgba(0, 0, 0, 0.3);
            }
            50% { 
                box-shadow: 
                    0 0 30px currentColor,
                    0 0 60px currentColor,
                    0 6px 16px rgba(0, 0, 0, 0.4);
            }
        }
        
        .preview-cell.player1,
        .preview-cell.player2 {
            animation: pulse-glow 3s ease-in-out infinite;
        }
        
        /* å“åº”å¼æ”¹è¿› */
        @media (max-width: 1024px) {
            .scene {
                min-h-[200px];
            }
            .cube {
                width: 180px;
                height: 180px;
            }
            .preview-cell {
                width: 22px;
                height: 22px;
                border-width: 1px;
            }
        }
        
        @media (max-width: 768px) {
            .scene {
                min-h-[160px];
                background: radial-gradient(ellipse at center, rgba(59, 130, 246, 0.05) 0%, rgba(0, 0, 0, 0.2) 70%);
            }
            .cube {
                width: 140px;
                height: 140px;
            }
            .preview-cell {
                width: 18px;
                height: 18px;
            }
            .preview-cell.player1,
            .preview-cell.player2 {
                animation: none; /* å‡å°‘ç§»åŠ¨ç«¯åŠ¨ç”»ä»¥æå‡æ€§èƒ½ */
            }
        }
        
        /* è§¦æ‘¸è®¾å¤‡ä¼˜åŒ– */
        @media (hover: none) {
            .cube:hover {
                transform: none;
                transition: none;
            }
            .preview-cell:hover {
                transform: none;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen font-sans p-4">

    <header class="text-center mb-6">
        <h1 class="text-4xl md:text-5xl font-bold tracking-tight">ç«‹ä½“å››å­æ£‹</h1>
        <p class="text-gray-400 mt-2">åœ¨ 4x4x4 çš„ç©ºé—´ä¸­è¿æˆå››å­ï¼</p>
    </header>

    <div class="w-full max-w-7xl grid grid-cols-1 lg:grid-cols-3 gap-8">
        <!-- Game Board Section -->
        <main id="game-container" class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-2xl w-full lg:col-span-2">
            <!-- Controls -->
            <div class="flex flex-col sm:flex-row justify-between items-center mb-4 gap-4">
                <div id="status-display" class="text-xl font-semibold h-8 flex items-center"></div>
                <div class="flex gap-2 sm:gap-4">
                    <select id="game-mode" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <option value="pvp">åŒäººå¯¹æˆ˜ (PvP)</option>
                        <option value="pve">äººæœºå¯¹æˆ˜ (PvE)</option>
                    </select>
                    <select id="difficulty" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <option value="easy">ç®€å•</option>
                        <option value="hard">å›°éš¾</option>
                    </select>
                    <button id="restart-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors">
                        é‡æ–°å¼€å§‹
                    </button>
                </div>
            </div>

            <!-- Game Board -->
            <div id="game-board" class="flex flex-row gap-4 md:gap-6 overflow-x-auto pb-4">
                <!-- Boards will be generated by JS -->
            </div>
        </main>

        <!-- Sidebar Section -->
        <aside class="flex flex-col gap-8">
            <div class="bg-gray-800 p-6 rounded-xl shadow-2xl">
                <h2 class="text-2xl font-bold mb-4 text-center">æ¸¸æˆä¿¡æ¯</h2>
                <button id="rules-btn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-md transition-colors">
                    ç©æ³•è¯´æ˜
                </button>
            </div>
            <div class="bg-gray-800 p-6 rounded-xl shadow-2xl flex-grow flex flex-col">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">ç«‹æ–¹ä½“é¢„è§ˆ</h2>
                    <div class="flex gap-2">
                        <button id="pause-rotation" class="bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-md transition-colors text-sm" title="æš‚åœ/ç»§ç»­æ—‹è½¬">
                            â¸ï¸
                        </button>
                        <button id="reset-view" class="bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-md transition-colors text-sm" title="é‡ç½®è§†è§’">
                            ğŸ”„
                        </button>
                    </div>
                </div>
                <div id="cube-preview-container" class="scene flex-grow min-h-[280px] relative">
                    <div class="absolute top-2 left-2 text-xs text-gray-400 bg-black bg-opacity-30 px-2 py-1 rounded backdrop-blur-sm z-10">
                        é¼ æ ‡æ‚¬åœå¯æš‚åœæ—‹è½¬
                    </div>
                </div>
                <div class="mt-3 text-center">
                    <div class="flex justify-center gap-4 text-sm text-gray-400">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-red-500"></div>
                            <span>çº¢æ–¹</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-yellow-400"></div>
                            <span>é»„æ–¹</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-gray-600 opacity-50"></div>
                            <span>ç©ºä½</span>
                        </div>
                    </div>
                </div>
            </div>
        </aside>
    </div>

    <!-- Rules Modal -->
    <div id="rules-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full p-8 relative">
            <button id="close-modal-btn" class="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">&times;</button>
            <h2 class="text-3xl font-bold mb-4 text-center">ç©æ³•è¯´æ˜</h2>
            <div class="text-gray-300 space-y-3">
                <p><strong>ç›®æ ‡ï¼š</strong>æˆä¸ºç¬¬ä¸€ä¸ªå°†è‡ªå·±çš„å››ä¸ªæ£‹å­è¿æˆä¸€æ¡ç›´çº¿çš„ç©å®¶ã€‚</p>
                <p><strong>æ£‹ç›˜ï¼š</strong>æ¸¸æˆåœ¨ä¸€ä¸ª 4x4x4 çš„ç«‹ä½“ç©ºé—´ä¸­è¿›è¡Œã€‚ç•Œé¢ä¸Šä»å·¦åˆ°å³çš„å››ä¸ªç½‘æ ¼åˆ†åˆ«ä»£è¡¨ç«‹æ–¹ä½“ä»**åº•éƒ¨åˆ°é¡¶éƒ¨**çš„å››ä¸ªå±‚é¢ã€‚</p>
                <p><strong>ä¸‹æ£‹ (æ–°è§„åˆ™)ï¼š</strong>è½®åˆ°ä½ æ—¶ï¼Œåœ¨**ä»»æ„å±‚é¢**ä¸Šç‚¹å‡»ä¸€ä¸ª**æ ¼å­**ã€‚è¿™ä»£è¡¨ä½ é€‰æ‹©äº†ä¸€ä¸ªå‚ç›´çš„â€œäº•é“â€ã€‚ä½ çš„æ£‹å­ä¼šè‡ªåŠ¨è½åˆ°è¯¥â€œäº•é“â€ä¸­æœ€ä½çš„å¯ç”¨ä½ç½®ã€‚</p>
                <p><strong>èƒœåˆ©æ¡ä»¶ï¼š</strong>å››å­ç›¸è¿å³å¯è·èƒœã€‚è¿çº¿å¯ä»¥æ˜¯ï¼š</p>
                <ul class="list-disc list-inside pl-4 space-y-1">
                    <li><strong>æ°´å¹³çº¿ï¼š</strong>åœ¨åŒä¸€å±‚å†…çš„è¡Œã€åˆ—æˆ–å¯¹è§’çº¿ã€‚</li>
                    <li><strong>å‚ç›´çº¿ï¼š</strong>è´¯ç©¿å››ä¸ªä¸åŒå±‚é¢çš„ç›´çº¿ï¼ˆåœ¨åŒä¸€ä¸ªâ€œäº•é“â€ä¸­ï¼‰ã€‚</li>
                    <li><strong>ç©ºé—´å¯¹è§’çº¿ï¼š</strong>è´¯ç©¿æ•´ä¸ªç«‹æ–¹ä½“çš„å¯¹è§’çº¿ã€‚</li>
                </ul>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const BOARD_SIZE = 4;
            const gameBoardElement = document.getElementById('game-board');
            const statusDisplay = document.getElementById('status-display');
            const restartBtn = document.getElementById('restart-btn');
            const gameModeSelect = document.getElementById('game-mode');
            const difficultySelect = document.getElementById('difficulty');
            const cubePreviewContainer = document.getElementById('cube-preview-container');
            const pauseRotationBtn = document.getElementById('pause-rotation');
            const resetViewBtn = document.getElementById('reset-view');
            const rulesBtn = document.getElementById('rules-btn');
            const rulesModal = document.getElementById('rules-modal');
            const closeModalBtn = document.getElementById('close-modal-btn');

            let board = [];
            let currentPlayer = 1;
            let gameOver = false;
            let gameMode = 'pvp';
            let difficulty = 'easy';
            let rotationPaused = false;
            let cubeElement = null;

            const initGame = () => {
                board = Array(BOARD_SIZE).fill(0).map(() =>
                    Array(BOARD_SIZE).fill(0).map(() =>
                        Array(BOARD_SIZE).fill(0)
                    )
                );
                currentPlayer = 1;
                gameOver = false;
                gameMode = gameModeSelect.value;
                difficulty = difficultySelect.value;
                renderBoard();
                updateStatus();
            };

            const renderBoard = () => {
                gameBoardElement.innerHTML = '';
                for (let level = 0; level < BOARD_SIZE; level++) {
                    const levelElement = document.createElement('div');
                    levelElement.className = 'board-level bg-gray-700 p-2 rounded-lg shadow-lg w-48 sm:w-56 flex-shrink-0';
                    
                    let levelLabel = `ç¬¬ ${level + 1} å±‚`;
                    if (level === 0) levelLabel += ' (åº•éƒ¨)';
                    if (level === BOARD_SIZE - 1) levelLabel += ' (é¡¶éƒ¨)';
                    
                    levelElement.innerHTML = `<h3 class="text-center font-bold mb-2 text-gray-300">${levelLabel}</h3>`;
                    
                    const gridElement = document.createElement('div');
                    gridElement.className = 'board-grid grid grid-cols-4 gap-2';
                    gridElement.dataset.level = level;
                    
                    for (let row = 0; row < BOARD_SIZE; row++) {
                        for (let col = 0; col < BOARD_SIZE; col++) {
                            const cellContainer = document.createElement('div');
                            cellContainer.className = 'cell-container';
                            cellContainer.dataset.row = row;
                            cellContainer.dataset.col = col;

                            // NEW: Check if the entire shaft is full
                            if (board[BOARD_SIZE - 1][row][col] !== 0) {
                                cellContainer.classList.add('shaft-full');
                            }

                            const cellElement = document.createElement('div');
                            cellElement.className = 'cell';
                            const player = board[level][row][col];
                            if (player === 1) cellElement.classList.add('player1');
                            if (player === 2) cellElement.classList.add('player2');
                            
                            cellContainer.appendChild(cellElement);
                            gridElement.appendChild(cellContainer);
                        }
                    }
                    levelElement.appendChild(gridElement);
                    gameBoardElement.appendChild(levelElement);
                }
                addEventListenersToBoards();
                renderCubePreview();
            };

            const renderCubePreview = () => {
                cubePreviewContainer.innerHTML = '';
                const cube = document.createElement('div');
                cube.className = 'cube';
                cubeElement = cube;

                // åº”ç”¨æš‚åœçŠ¶æ€
                if (rotationPaused) {
                    cube.style.animationPlayState = 'paused';
                }

                // å“åº”å¼å•å…ƒæ ¼å¤§å°
                const getResponsiveCellSize = () => {
                    const width = window.innerWidth;
                    if (width <= 768) {
                        return { cellSize: 20, gap: 10 };
                    } else if (width <= 1024) {
                        return { cellSize: 26, gap: 13 };
                    } else {
                        return { cellSize: 32, gap: 16 };
                    }
                };

                const { cellSize: CELL_SIZE, gap: GAP } = getResponsiveCellSize();
                const TOTAL_SIZE = CELL_SIZE + GAP;
                const offset = - (BOARD_SIZE - 1) * TOTAL_SIZE / 2;

                for (let l = 0; l < BOARD_SIZE; l++) {
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            const cell = document.createElement('div');
                            cell.className = 'preview-cell';
                            const player = board[l][r][c];
                            
                            if (player === 1) cell.classList.add('player1');
                            else if (player === 2) cell.classList.add('player2');
                            else cell.classList.add('empty');

                            // MODIFIED: Re-oriented coordinates for preview
                            // x = column, y = level (height), z = row (depth)
                            const x = offset + c * TOTAL_SIZE;
                            const y = offset + (BOARD_SIZE - 1 - l) * TOTAL_SIZE; // Y is now level, inverted so 0 is at the bottom
                            const z = offset + r * TOTAL_SIZE;

                            cell.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
                            
                            // æ·»åŠ æ•°æ®å±æ€§ç”¨äºè°ƒè¯•
                            cell.dataset.level = l;
                            cell.dataset.row = r;
                            cell.dataset.col = c;
                            
                            cube.appendChild(cell);
                        }
                    }
                }
                
                // ä¿ç•™æç¤ºæ–‡æœ¬
                const existingHint = cubePreviewContainer.querySelector('.absolute');
                cubePreviewContainer.appendChild(cube);
                if (existingHint) {
                    cubePreviewContainer.appendChild(existingHint);
                }
            };

            const toggleRotation = () => {
                rotationPaused = !rotationPaused;
                if (cubeElement) {
                    cubeElement.style.animationPlayState = rotationPaused ? 'paused' : 'running';
                }
                pauseRotationBtn.textContent = rotationPaused ? 'â–¶ï¸' : 'â¸ï¸';
                pauseRotationBtn.title = rotationPaused ? 'ç»§ç»­æ—‹è½¬' : 'æš‚åœæ—‹è½¬';
            };

            const resetView = () => {
                if (cubeElement) {
                    cubeElement.style.transform = 'rotateX(-20deg) rotateY(0deg) rotateZ(-5deg)';
                    cubeElement.style.animation = 'none';
                    setTimeout(() => {
                        cubeElement.style.animation = rotationPaused ? 'spin 30s infinite linear' : 'spin 30s infinite linear';
                        cubeElement.style.animationPlayState = rotationPaused ? 'paused' : 'running';
                    }, 50);
                }
            };

            const updateStatus = () => {
                if (gameOver) return;
                const playerColor = currentPlayer === 1 ? 'text-red-500' : 'text-yellow-400';
                const playerName = currentPlayer === 1 ? 'çº¢æ–¹' : 'é»„æ–¹';
                statusDisplay.innerHTML = `è½®åˆ° <span class="${playerColor} font-bold">${playerName}</span>`;
            };

            // NEW: Handles clicks based on vertical shafts
            const handleShaftClick = (e) => {
                if (gameOver || (gameMode === 'pve' && currentPlayer === 2)) return;

                const cellContainer = e.target.closest('.cell-container');
                if (!cellContainer || cellContainer.classList.contains('shaft-full')) return;

                const row = parseInt(cellContainer.dataset.row);
                const col = parseInt(cellContainer.dataset.col);

                // Find the lowest empty level in this shaft
                let landingLevel = -1;
                for (let l = 0; l < BOARD_SIZE; l++) {
                    if (board[l][row][col] === 0) {
                        landingLevel = l;
                        break;
                    }
                }

                if (landingLevel !== -1) {
                    makeMove(landingLevel, row, col);
                }
            };
            
            const makeMove = (level, row, col) => {
                if (gameOver || board[level][row][col] !== 0) return;

                board[level][row][col] = currentPlayer;
                renderBoard();

                if (checkWin(currentPlayer)) {
                    gameOver = true;
                    const playerColor = currentPlayer === 1 ? 'text-red-500' : 'text-yellow-400';
                    const playerName = currentPlayer === 1 ? 'çº¢æ–¹' : 'é»„æ–¹';
                    statusDisplay.innerHTML = `<span class="${playerColor} font-bold">${playerName}</span> è·èƒœ! ğŸ‰`;
                    return;
                }

                if (checkDraw()) {
                    gameOver = true;
                    statusDisplay.textContent = 'å¹³å±€!';
                    return;
                }

                switchPlayer();

                if (gameMode === 'pve' && currentPlayer === 2 && !gameOver) {
                    setTimeout(aiMove, 500);
                }
            };

            const switchPlayer = () => {
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                updateStatus();
            };

            // MODIFIED: Event listeners are now on the grids for delegation
            const addEventListenersToBoards = () => {
                document.querySelectorAll('.board-grid').forEach(grid => {
                    grid.addEventListener('click', handleShaftClick);
                });
            };

            const checkWin = (player) => {
                // The win checking logic itself doesn't need to change, as it correctly
                // checks all 3D dimensions of the data array.
                // 1. Horizontal (within each level: row, col, and diagonal)
                for (let l = 0; l < BOARD_SIZE; l++) {
                    for (let r = 0; r < BOARD_SIZE; r++) { // Check rows
                        if (board[l][r][0] === player && board[l][r][1] === player && board[l][r][2] === player && board[l][r][3] === player) return true;
                    }
                    for (let c = 0; c < BOARD_SIZE; c++) { // Check columns
                        if (board[l][0][c] === player && board[l][1][c] === player && board[l][2][c] === player && board[l][3][c] === player) return true;
                    }
                    // Check diagonals
                    if (board[l][0][0] === player && board[l][1][1] === player && board[l][2][2] === player && board[l][3][3] === player) return true;
                    if (board[l][0][3] === player && board[l][1][2] === player && board[l][2][1] === player && board[l][3][0] === player) return true;
                }

                // 2. Vertical (through levels)
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[0][r][c] === player && board[1][r][c] === player && board[2][r][c] === player && board[3][r][c] === player) return true;
                    }
                }

                // 3. Diagonal (through levels)
                for (let i = 0; i < BOARD_SIZE; i++) {
                    // Diagonal in row-level plane
                    if (board[0][0][i] === player && board[1][1][i] === player && board[2][2][i] === player && board[3][3][i] === player) return true;
                    if (board[0][3][i] === player && board[1][2][i] === player && board[2][1][i] === player && board[3][0][i] === player) return true;
                    // Diagonal in col-level plane
                    if (board[0][i][0] === player && board[1][i][1] === player && board[2][i][2] === player && board[3][i][3] === player) return true;
                    if (board[0][i][3] === player && board[1][i][2] === player && board[2][i][1] === player && board[3][i][0] === player) return true;
                }

                // 4. Main 3D space diagonals
                if (board[0][0][0] === player && board[1][1][1] === player && board[2][2][2] === player && board[3][3][3] === player) return true;
                if (board[0][0][3] === player && board[1][1][2] === player && board[2][2][1] === player && board[3][3][0] === player) return true;
                if (board[0][3][0] === player && board[1][2][1] === player && board[2][1][2] === player && board[3][0][3] === player) return true;
                if (board[3][0][0] === player && board[2][1][1] === player && board[1][2][2] === player && board[0][3][3] === player) return true;

                return false;
            };

            const checkDraw = () => {
                // A draw occurs if all shafts are full (i.e., the top layer is full)
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[BOARD_SIZE - 1][r][c] === 0) return false;
                    }
                }
                return true;
            };
            
            // å¢å¼ºçš„AIç®—æ³• - è¯„ä¼°å‡½æ•°
            const evaluateBoard = (player) => {
                let score = 0;
                const opponent = player === 1 ? 2 : 1;

                // è¯„ä¼°æ‰€æœ‰å¯èƒ½çš„å››å­è¿çº¿
                score += evaluateLines(player, opponent);
                
                // ä¸­å¿ƒä½ç½®æƒé‡
                score += evaluateCenterControl(player, opponent);
                
                return score;
            };

            const evaluateLines = (player, opponent) => {
                let score = 0;
                
                // è¯„ä¼°æ‰€æœ‰å¯èƒ½çš„è¿çº¿æ–¹å‘
                const directions = getAllWinDirections();
                
                for (const direction of directions) {
                    const lineScore = evaluateLine(direction, player, opponent);
                    score += lineScore;
                }
                
                return score;
            };

            const getAllWinDirections = () => {
                const directions = [];
                
                // 1. æ°´å¹³çº¿ (åŒä¸€å±‚å†…)
                for (let l = 0; l < BOARD_SIZE; l++) {
                    // è¡Œ
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        directions.push([[l, r, 0], [l, r, 1], [l, r, 2], [l, r, 3]]);
                    }
                    // åˆ—
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        directions.push([[l, 0, c], [l, 1, c], [l, 2, c], [l, 3, c]]);
                    }
                    // å¯¹è§’çº¿
                    directions.push([[l, 0, 0], [l, 1, 1], [l, 2, 2], [l, 3, 3]]);
                    directions.push([[l, 0, 3], [l, 1, 2], [l, 2, 1], [l, 3, 0]]);
                }

                // 2. å‚ç›´çº¿ (è´¯ç©¿å±‚)
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        directions.push([[0, r, c], [1, r, c], [2, r, c], [3, r, c]]);
                    }
                }

                // 3. ç©ºé—´å¯¹è§’çº¿
                for (let i = 0; i < BOARD_SIZE; i++) {
                    // è¡Œ-å±‚å¹³é¢å¯¹è§’çº¿
                    directions.push([[0, 0, i], [1, 1, i], [2, 2, i], [3, 3, i]]);
                    directions.push([[0, 3, i], [1, 2, i], [2, 1, i], [3, 0, i]]);
                    // åˆ—-å±‚å¹³é¢å¯¹è§’çº¿
                    directions.push([[0, i, 0], [1, i, 1], [2, i, 2], [3, i, 3]]);
                    directions.push([[0, i, 3], [1, i, 2], [2, i, 1], [3, i, 0]]);
                }

                // 4. ä¸»ç©ºé—´å¯¹è§’çº¿
                directions.push([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]]);
                directions.push([[0, 0, 3], [1, 1, 2], [2, 2, 1], [3, 3, 0]]);
                directions.push([[0, 3, 0], [1, 2, 1], [2, 1, 2], [3, 0, 3]]);
                directions.push([[3, 0, 0], [2, 1, 1], [1, 2, 2], [0, 3, 3]]);

                return directions;
            };

            const evaluateLine = (line, player, opponent) => {
                let playerCount = 0;
                let opponentCount = 0;
                let emptyCount = 0;

                for (const [l, r, c] of line) {
                    const cell = board[l][r][c];
                    if (cell === player) playerCount++;
                    else if (cell === opponent) opponentCount++;
                    else emptyCount++;
                }

                // å¦‚æœå¯¹æ‰‹å·²ç»å æ®äº†è¿™æ¡çº¿ï¼Œè¿™æ¡çº¿å¯¹æˆ‘ä»¬æ²¡æœ‰ä»·å€¼
                if (opponentCount > 0 && playerCount > 0) return 0;
                
                // è¯„åˆ†ç­–ç•¥
                if (playerCount === 4) return 10000; // èƒœåˆ©
                if (opponentCount === 4) return -10000; // å¤±è´¥
                if (playerCount === 3 && emptyCount === 1) return 500; // å³å°†èƒœåˆ©
                if (opponentCount === 3 && emptyCount === 1) return -500; // å¿…é¡»é˜»æ­¢
                if (playerCount === 2 && emptyCount === 2) return 50; // æœ‰æ½œåŠ›
                if (opponentCount === 2 && emptyCount === 2) return -50; // éœ€è¦å…³æ³¨
                if (playerCount === 1 && emptyCount === 3) return 5; // åŸºç¡€åˆ†
                if (opponentCount === 1 && emptyCount === 3) return -5; // å¯¹æ‰‹åŸºç¡€åˆ†

                return 0;
            };

            const evaluateCenterControl = (player, opponent) => {
                let score = 0;
                const center = Math.floor(BOARD_SIZE / 2);
                
                // ä¸­å¿ƒä½ç½®æ›´æœ‰ä»·å€¼
                for (let l = 0; l < BOARD_SIZE; l++) {
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            const distance = Math.abs(r - center) + Math.abs(c - center);
                            const weight = BOARD_SIZE - distance;
                            
                            if (board[l][r][c] === player) {
                                score += weight * 2;
                            } else if (board[l][r][c] === opponent) {
                                score -= weight * 2;
                            }
                        }
                    }
                }
                
                return score;
            };

            // Minimaxç®—æ³•å®ç°
            const minimax = (depth, isMaximizing, alpha = -Infinity, beta = Infinity) => {
                // æ£€æŸ¥æ¸¸æˆç»“æŸçŠ¶æ€
                if (checkWin(2)) return 10000 - depth; // AIèƒœåˆ©ï¼Œæ·±åº¦è¶Šæµ…è¶Šå¥½
                if (checkWin(1)) return -10000 + depth; // ç©å®¶èƒœåˆ©ï¼Œæ·±åº¦è¶Šæ·±è¶Šå¥½
                if (checkDraw() || depth === 0) return evaluateBoard(2);

                const validMoves = getValidMoves();
                if (validMoves.length === 0) return evaluateBoard(2);

                if (isMaximizing) {
                    let maxEval = -Infinity;
                    for (const move of validMoves) {
                        const level = getLandingLevel(move.row, move.col);
                        board[level][move.row][move.col] = 2; // AIç©å®¶
                        
                        const eval = minimax(depth - 1, false, alpha, beta);
                        board[level][move.row][move.col] = 0; // æ’¤é”€ç§»åŠ¨
                        
                        maxEval = Math.max(maxEval, eval);
                        alpha = Math.max(alpha, eval);
                        if (beta <= alpha) break; // Alpha-betaå‰ªæ
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (const move of validMoves) {
                        const level = getLandingLevel(move.row, move.col);
                        board[level][move.row][move.col] = 1; // äººç±»ç©å®¶
                        
                        const eval = minimax(depth - 1, true, alpha, beta);
                        board[level][move.row][move.col] = 0; // æ’¤é”€ç§»åŠ¨
                        
                        minEval = Math.min(minEval, eval);
                        beta = Math.min(beta, eval);
                        if (beta <= alpha) break; // Alpha-betaå‰ªæ
                    }
                    return minEval;
                }
            };

            const getValidMoves = () => {
                const moves = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[BOARD_SIZE - 1][r][c] === 0) { // äº•é“æœªæ»¡
                            moves.push({ row: r, col: c });
                        }
                    }
                }
                return moves;
            };

            const getBestMove = () => {
                const validMoves = getValidMoves();
                if (validMoves.length === 0) return null;

                let bestMove = null;
                let bestScore = -Infinity;
                const searchDepth = difficulty === 'hard' ? 4 : 2; // å›°éš¾æ¨¡å¼æœç´¢æ›´æ·±

                for (const move of validMoves) {
                    const level = getLandingLevel(move.row, move.col);
                    board[level][move.row][move.col] = 2; // AIç©å®¶
                    
                    const score = minimax(searchDepth - 1, false);
                    board[level][move.row][move.col] = 0; // æ’¤é”€ç§»åŠ¨
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }

                return bestMove;
            };

            // REWRITTEN: AI logic to work with new gravity
            const aiMove = () => {
                if (gameOver) return;
                let bestMove = null; // {row, col}

                if (difficulty === 'hard') {
                    // å›°éš¾æ¨¡å¼ï¼šä½¿ç”¨minimaxç®—æ³•
                    bestMove = getBestMove();
                } else {
                    // ç®€å•æ¨¡å¼ï¼šä½¿ç”¨åŸæ¥çš„ç®€å•ç­–ç•¥
                    // 1. Check if AI can win by dropping in any shaft
                    bestMove = findWinningShaft(2);

                    // 2. Check if player can win and block
                    if (!bestMove) {
                        bestMove = findWinningShaft(1);
                    }

                    // 3. If no winning/blocking move, choose a random valid shaft
                    if (!bestMove) {
                        const validShafts = [];
                        for (let r = 0; r < BOARD_SIZE; r++) {
                            for (let c = 0; c < BOARD_SIZE; c++) {
                                if (board[BOARD_SIZE - 1][r][c] === 0) { // Shaft is not full
                                    validShafts.push({ r, c });
                                }
                            }
                        }
                        if (validShafts.length > 0) {
                            const randomChoice = validShafts[Math.floor(Math.random() * validShafts.length)];
                            bestMove = { row: randomChoice.r, col: randomChoice.c };
                        }
                    }
                }
                
                if (bestMove) {
                    const landingLevel = getLandingLevel(bestMove.row, bestMove.col);
                    if (landingLevel !== -1) {
                        makeMove(landingLevel, bestMove.row, bestMove.col);
                    }
                }
            };

            // NEW AI HELPER: Finds the landing level for a given shaft
            const getLandingLevel = (row, col) => {
                for (let l = 0; l < BOARD_SIZE; l++) {
                    if (board[l][row][col] === 0) return l;
                }
                return -1; // Shaft is full
            };

            // NEW AI HELPER: Finds a shaft where a player can win
            const findWinningShaft = (player) => {
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const l = getLandingLevel(r, c);
                        if (l !== -1) { // If shaft is not full
                            board[l][r][c] = player; // Try move
                            if (checkWin(player)) {
                                board[l][r][c] = 0; // Revert
                                return { row: r, col: c };
                            }
                            board[l][r][c] = 0; // Revert
                        }
                    }
                }
                return null;
            };

            // Event Listeners
            restartBtn.addEventListener('click', initGame);
            gameModeSelect.addEventListener('change', initGame);
            difficultySelect.addEventListener('change', initGame);
            pauseRotationBtn.addEventListener('click', toggleRotation);
            resetViewBtn.addEventListener('click', resetView);
            rulesBtn.addEventListener('click', () => rulesModal.classList.remove('hidden'));
            closeModalBtn.addEventListener('click', () => rulesModal.classList.add('hidden'));
            rulesModal.addEventListener('click', (e) => {
                if (e.target === rulesModal) rulesModal.classList.add('hidden');
            });

            // å“åº”å¼å¤„ç†
            window.addEventListener('resize', () => {
                clearTimeout(window.resizeTimeout);
                window.resizeTimeout = setTimeout(() => {
                    renderCubePreview();
                }, 250);
            });

            // Initial game start
            initGame();
        });
    </script>

</body>
</html>
